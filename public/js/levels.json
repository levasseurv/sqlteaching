[{"name": "Sélectionner tous les champs",
  "short_name": "select",
  "database_type": "famille",
  "answer": {"columns": ["id", "nom", "livres_lus"],
    "values": [[1, "Dave", 200],
      [2, "Marie", 180],
      [3, "Chaton", 0]]},
    "prompt": "Sélectionner tous les membres de la famille. Afficher toutes leurs caractéristiques."},

  {"name": "Sélectionner des champs spécifiques",
    "short_name": "select_columns",
    "database_type": "famille",
    "answer": {"columns": ["nom", "livres_lus"],
      "values": [["Dave", 200],
        ["Marie", 180],
        ["Chaton", 0]]},
    "prompt": "Sélectionner le nom et le nombre de livres lus des membres de la famille."},

  {"name": "Filtrer des données",
    "short_name": "where_equals",
    "database_type": "famille",
    "answer": {"columns": ["id", "nom", "livres_lus"],
      "values": [[3, "Chaton", 0]]},
    "prompt": "Sélectionner le membre de la famille dont le id est 3"},

  {"name": "Opérateurs de comparaison",
    "short_name": "where_greater_than",
    "database_type": "famille",
    "answer": {"columns": ["nom"],
      "values": [["Dave"], ["Marie"]]},
    "prompt": "Sélectionner les noms des membres de la famille qui ont lu 180 livres et plus"},

  {"name": "Opérateur logique AND",
    "short_name": "and",
    "database_type": "amischaton",
    "answer": {"columns": ["id", "nom", "type", "taille_cm"],
      "values": [[5, "Odie", "chien", 40],
        [6, "Pitou", "chien", 35]]},
    "prompt": "On peut combiner plusieurs conditions dans la partie <code>WHERE</code> de la requête. Par exemple, si on veut trouver les amis chats de Chaton qui ont plus de 25cm, on peut utiliser la requête : <br/><code>SELECT * FROM amis_chaton WHERE taille_cm > 25 AND type = 'chat';</code><br/><br/>Trouver les amis chiens de Chaton qui font moins de 45cm."},

  {"name": "OR",
    "short_name": "or",
    "database_type": "amis_chaton",
    "answer": {"columns": ["id", "nom", "gender", "type", "taille_cm"],
      "values": [[3, "Frisou", "male", "cat", 30],
        [4, "Leela", "female", "cat", 25],
        [5, "Odie", "male", "chien", 40],
        [6, "Pitou", "male", "chien", 35],
        [7, "Jojo", "male", "chien", 55]]},
    "prompt": "In the <code>WHERE</code> part of a query, you can search for rows that match any of multiple attributes by using the <code>OR</code> keyword.  For example, if you wanted to find the friends of Pickles that are over 25cm in height or are cats, you would run: <br/><code>SELECT * FROM amis_chaton WHERE taille_cm > 25 OR type = 'cat';</code><br/><br/>Can you find all of Pickles' friends that are chiens or under the height of 45cm?"},

  {"name": "IN",
    "short_name": "in",
    "database_type": "amis_chaton",
    "answer": {"columns": ["id", "nom", "gender", "type", "taille_cm"],
      "values": [[1, "Dave", "male", "human", 180],
        [2, "Marie", "female", "human", 160]]},
    "prompt": "Using the <code>WHERE</code> clause, we can find rows where a value is in a list of several possible values. <br/><br/><code>SELECT * FROM amis_chaton WHERE type IN ('cat', 'human');</code> would return the <strong>amis_chaton</strong> that are either a cat or a human. <br/><br/>To find rows that are not in a list, you use <code>NOT IN</code> instead of <code>IN</code>. <br/><br/>Can you run a query that would return the rows that are <strong>not</strong> cats or chiens?"},

  {"name": "DISTINCT",
    "short_name": "distinct",
    "database_type": "amis_chaton",
    "answer": {"columns": ["type"],
      "values": [["human"], ["chien"]]},
    "prompt": "By putting <code>DISTINCT</code> after <code>SELECT</code>, you do not return duplicates. <br/><br/>For example, if you run <br/> <code>SELECT DISTINCT gender, type FROM amis_chaton WHERE taille_cm < 100;</code>, you will get the gender/type combinations of the animals less than 100cm in height. <br/><br/>Note that even though there are multiple male chiens under that height, we only see one row that returns \"male\" and \"chien\".<br/><br/> Can you return a list of the distinct type of animals greater than 50cm in height?"},

  {"name": "ORDER BY",
    "short_name": "order_by",
    "database_type": "amis_chaton",
    "answer": {"columns": ["id", "nom", "gender", "type", "taille_cm"],
      "values": [[1, "Dave", "male", "human", 180],
        [2, "Marie", "female", "human", 160],
        [7, "Jojo", "male", "chien", 55],
        [5, "Odie", "male", "chien", 40],
        [6, "Pitou", "male", "chien", 35],
        [3, "Frisou", "male", "cat", 30],
        [4, "Leela", "female", "cat", 25]]},
    "prompt": "If you want to sort the rows by some kind of attribute, you can use the <code>ORDER BY</code> keyword.  For example, if you want to sort the <strong>amis_chaton</strong> by nom, you would run: <code>SELECT * FROM amis_chaton ORDER BY nom;</code>.  That returns the noms in ascending alphabetical order.<br/><br/> In order to put the noms in descending order, you would add a <code>DESC</code> at the end of the query.<br/><br/> Can you run a query that sorts the <strong>amis_chaton</strong> by <em>taille_cm</em> in descending order?"},

  {"name": "LIMIT # of returned rows",
    "short_name": "limit",
    "database_type": "amis_chaton",
    "answer": {"columns": ["id", "nom", "gender", "type", "taille_cm"],
      "values": [[1, "Dave", "male", "human", 180]]},
    "prompt": "Often, tables contain millions of rows, and it can take a while to grab everything. If we just want to see a few examples of the data in a table, we can select the first few rows with the <code>LIMIT</code> keyword. If you use <code>ORDER BY</code>, you would get the first rows for that order. <br/><br/>If you wanted to see the two shortest <strong>amis_chaton</strong>, you would run: <code>SELECT * FROM amis_chaton ORDER BY taille_cm LIMIT 2;</code><br/><br/> Can you return the single row (and all columns) of the tallest <strong>amis_chaton</strong>?<br/><br/>Note: <br/>- Some letiants of SQL do not use the <code>LIMIT</code> keyword.<br/>- The <code>LIMIT</code> keyword comes after the <code>DESC</code> keyword."},

  {"name": "COUNT(*)",
    "short_name": "count",
    "database_type": "amis_chaton",
    "answer": {"columns": ["COUNT(*)"],
      "values": [[7]]},
    "prompt": "Another way to explore a table is to check the number of rows in it. For example, if we are querying a table <em>states_of_us</em>, we'd expect 50 rows, or 500 rows in a table called <em>fortune_500_companies</em>.<br/><br/><code>SELECT COUNT(*) FROM amis_chaton;</code> returns the total number of rows in the table <strong>amis_chaton</strong>. Try this for yourself."},

  {"name": "COUNT(*) ... WHERE",
    "short_name": "count_where",
    "database_type": "amis_chaton",
    "answer": {"columns": ["COUNT(*)"],
      "values": [[3]]},
    "prompt": "We can combine <code>COUNT(*)</code> with <code>WHERE</code> to return the number of rows that matches the <code>WHERE</code> clause.<br/><br/> For example, <code>SELECT COUNT(*) FROM amis_chaton WHERE type = 'human';</code> returns 2.<br/><br/>Can you return the number of rows in <strong>amis_chaton</strong> where the type is a chien?"},

  {"name": "SUM",
    "short_name": "sum",
    "database_type": "family_and_legs",
    "answer": {"columns": ["SUM(num_books_read)"],
      "values": [[380]]},
    "prompt": "We can use the <code>SUM</code> keyword in order to find the sum of a given value. <br/><br/>For example, running <code>SELECT SUM(num_legs) FROM family_members;</code> returns the total number of legs in the family. <br/><br/>Can you find the total num_books_read made by this family?"},

  {"name": "AVG",
    "short_name": "avg",
    "database_type": "family_and_legs",
    "answer": {"columns": ["AVG(num_books_read)"],
      "values": [[126.66666666666667]]},
    "prompt": "We can use the <code>AVG</code> keyword in order to find the average of a given value. <br/><br/>For example, running <code>SELECT AVG(num_legs) FROM family_members;</code> returns the average number of legs of each family member. <br/><br/>Can you find the average num_books_read made by each family member? <br/><br/>Note: <br/>- Because of the way computers handle numbers, averages will not always be completely exact."},

  {"name": "MAX and MIN",
    "short_name": "max_min",
    "database_type": "family_and_legs",
    "answer": {"columns": ["MAX(num_books_read)"],
      "values": [[200]]},
    "prompt": "We can use the <code>MAX</code> and <code>MIN</code> to find the maximum or minimum value of a table. <br/><br/>To find the least number of legs in a family member (<em>2</em>), you can run <br/><code>SELECT MIN(num_legs) FROM family_members;</code> <br/><br/>Can you find the highest num_books_read that a family member makes?"},

  {"name": "GROUP BY",
    "short_name": "group_by",
    "database_type": "amis_chaton",
    "answer": {"columns": ["MAX(taille_cm)", "type"],
      "values": [[30, "cat"],
        [55, "chien"],
        [180, "human"]]},
    "prompt": "You can use aggregate functions such as <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, and <code>MIN</code> with the <code>GROUP BY</code> clause. <br/><br/> When you <code>GROUP BY</code> something, you split the table into different piles based on the value of each row. <br/><br/>For example, <br/><code>SELECT COUNT(*), type FROM amis_chaton GROUP BY type;</code> would return the number of rows for each type. <br/><br/> Can you return the tallest height for each type? Remember to return the type name next to the height too, like in the example query."},

  {"name": "Nested queries",
    "short_name": "nested",
    "database_type": "family_and_legs",
    "required": ["(", ")"],
    "custom_error_message": "You must use a nested query in your answer.",
    "answer": {"columns": ["id", "name", "type", "num_books_read", "num_legs"],
      "values": [[1, "Dave", "human", 200, 2]]},
    "prompt": "In SQL, you can put a SQL query inside another SQL query. <br/><br/>For example, to find the family members with the least number of legs, <br/> you can run: <br/><code>SELECT * FROM family_members WHERE num_legs = (SELECT MIN(num_legs) FROM family_members);</code> <br/><br/> The <code>SELECT</code> query inside the parentheses is executed first, and returns the minimum number of legs.  Then, that value (2) is used in the outside query, to find all family members that have 2 legs. <br/><br/> Can you return the family members that have the highest num_books_read?"},

  {"name": "NULL",
    "short_name": "null",
    "database_type": "family_null",
    "answer": {"columns": ["id", "name", "gender", "type", "favorite_book"],
      "values": [[1, "Dave", "male", "human", "To Kill a Mockingbird"],
        [2, "Marie", "female", "human", "Gone with the Wind"]]},
    "prompt": "Sometimes, in a given row, there is no value at all for a given column.  For example, a chien does not have a favorite book, so in that case there is no point in putting a value in the <em>favorite_book</em> column, and the value is <code>NULL</code>.  In order to find the rows where the value for a column is or is not <code>NULL</code>, you would use <code>IS NULL</code> or <code>IS NOT NULL</code>.<br/><br/>Can you return all of the rows of <strong>family_members</strong> where <em>favorite_book</em> is not null?"},

  {"name": "Date",
    "short_name": "date",
    "database_type": "celebs_born",
    "answer": {"columns": ["id", "name", "birthdate"],
      "values": [[2, "Justin Timberlake", "1981-01-31"],
        [3, "Taylor Swift", "1989-12-13"]]},
    "prompt": "Sometimes, a column can contain a date value.  The first 4 digits represents the year, the next 2 digits represents the month, and the next 2 digits represents the day of the month.  For example, <code>1985-07-20</code> would mean July 20, 1985.<br/><br/>You can compare dates by using <code><</code> and <code>></code>.  For example, <code>SELECT * FROM celebs_born WHERE birthdate < '1985-08-17';</code> returns a list of celebrities that were born before August 17th, 1985.<br/><br/>Can you return a list of celebrities that were born after September 1st, 1980?"},

  {"name": "Inner joins",
    "short_name": "joins",
    "database_type": "tv",
    "answer": {"columns": ["name", "actor_name"],
      "values": [["Doogie Howser", "Neil Patrick Harris"],
        ["Barney Stinson", "Neil Patrick Harris"],
        ["Lily Aldrin", "Alyson Hannigan"],
        ["Willow Rosenberg", "Alyson Hannigan"]]},
    "prompt": "Different parts of information can be stored in different tables, and in order to put them together, we use <code>INNER JOIN ... ON</code>. Joining tables gets to the core of SQL functionality, but it can get very complicated. We will start with a simple example, and will start with an <code>INNER JOIN</code>.<br/><br/>As you can see below, there are 3 tables:<br/><strong>character</strong>: Each character is a row and is represented by a unique identifier (<em>id</em>), e.g. 1 is Doogie Howser<br/><strong>character_tv_show:</strong> For each character, which show is he/she in?<br/><strong>character_actor</strong>: For each character, who is the actor?<br/><br/>See that in <strong>character_tv_show</strong>, instead of storing both the character and TV show names (e.g. Willow Rosenberg and Buffy the Vampire Slayer), it stores the <em>character_id</em> as a substitute for the character name. This <em>character_id</em> refers to the matching <em>id</em> row from the <strong>character</strong> table. <br/><br/>This is done so data is not duplicated.  For example, if the name of a character were to change, you would only have to change the name of the character in one row. <br/><br/>This allows us to \"join\" the tables together \"on\" that reference/common column. <br/><br/>To get each character name with his/her TV show name, we can write <br/><code>SELECT character.name, character_tv_show.tv_show_name<br/> FROM character <br/>INNER JOIN character_tv_show<br/> ON character.id = character_tv_show.character_id;</code><br/>This puts together every row in <strong>character</strong> with the corresponding row in <strong>character_tv_show</strong>, or vice versa.<br/><br/>Note:<br/>- We use the syntax <strong>table_name</strong>.<em>column_name</em>. If we only used <em>column_name</em>, SQL might incorrectly assume which table it is coming from.<br/> - The example query above is written over multiple lines for readability, but that does not affect the query. <br/><br/>Can you use an inner join to pair each character name with the actor who plays them?  Select the columns: <strong>character</strong>.<em>name</em>, <strong>character_actor</strong>.<em>actor_name</em>"},

  {"name": "Multiple joins",
    "short_name": "multiple_joins",
    "database_type": "tv_normalized",
    "answer": {"columns": ["name", "name"],
      "values": [["Doogie Howser", "Neil Patrick Harris"],
        ["Barney Stinson", "Neil Patrick Harris"],
        ["Lily Aldrin", "Alyson Hannigan"],
        ["Willow Rosenberg", "Alyson Hannigan"]]},
    "prompt": "In the previous exercise, we explained that TV show character names were not duplicated, so if the name of a character were to change, you would only have to change the name of the character in one row. <br/><br/>However, the previous example was a bit artificial because the TV show names and actor names were duplicated. <br/><br/>In order to not duplicate any names, we need to have more tables, and use multiple joins. <br/><br/>We have tables for characters, TV shows, and actors.  Those tables represent things (also known as entities). <br/><br/>In addition those tables, we have the relationship tables <strong>character_tv_show</strong> and <strong>character_actor</strong>, which capture the relationship between two entities. <br/><br/>This is a flexible way of capturing the relationship between different entities, as some TV show characters might be in multiple shows, and some actors are known for playing multiple characters. <br/><br/>To get each character name with his/her TV show name, we can write <br/><code>SELECT character.name, tv_show.name<br/> FROM character <br/>INNER JOIN character_tv_show<br/> ON character.id = character_tv_show.character_id<br/>INNER JOIN tv_show<br/> ON character_tv_show.tv_show_id = tv_show.id;</code><br/><br/>Can you use two joins to pair each character name with the actor who plays them?  Select the columns: <strong>character</strong>.<em>name</em>, <strong>actor</strong>.<em>name</em>"},

  {"name": "Joins with WHERE",
    "short_name": "joins_with_where",
    "required": ["Willow Rosenberg", "How I Met Your Mother"],
    "custom_error_message": "You must check that the characters are not named \"Willow Rosenberg\" and not in the show \"How I Met Your Mother\".",
    "database_type": "tv_normalized",
    "answer": {"columns": ["name", "name"],
      "values": [["Doogie Howser", "Doogie Howser, M.D."]]},
    "prompt": "You can also use joins with the <code>WHERE</code> clause. <br/><br/> To get a list of characters and TV shows that are not in \"Buffy the Vampire Slayer\" and are not Barney Stinson, you would run: <br/> <code>SELECT character.name, tv_show.name<br/> FROM character <br/>INNER JOIN character_tv_show<br/> ON character.id = character_tv_show.character_id<br/>INNER JOIN tv_show<br/> ON character_tv_show.tv_show_id = tv_show.id WHERE character.name != 'Barney Stinson' AND tv_show.name != 'Buffy the Vampire Slayer';</code> <br/><br/>Can you return a list of characters and TV shows that are not named \"Willow Rosenberg\" and not in the show \"How I Met Your Mother\"?"},

  {"name": "Left joins",
    "short_name": "left_joins",
    "database_type": "tv_extra",
    "answer": {"columns": ["name", "name"],
      "values": [["Doogie Howser", "Neil Patrick Harris"],
        ["Barney Stinson", "Neil Patrick Harris"],
        ["Lily Aldrin", "Alyson Hannigan"],
        ["Willow Rosenberg", "Alyson Hannigan"],
        ["Steve Urkel", null],
        ["Homer Simpson", null]]},
    "prompt": "In the previous exercise, we used joins to match up TV character names with their actors.  When you use <code>INNER JOIN</code>, that is called an \"inner join\" because it only returns rows where there is data for both the character name and the actor. <br/><br/> However, perhaps you want to get all of the character names, even if there isn't corresponding data for the name of the actor.  A <code>LEFT JOIN</code> returns all of the data from the first (or \"left\") table, and if there isn't corresponding data for the second table, it returns <code>NULL</code> for those columns. <br/><br/> Using left joins between character names and TV shows would look like this: <br/><code>SELECT character.name, tv_show.name<br/> FROM character <br/>LEFT JOIN character_tv_show<br/> ON character.id = character_tv_show.character_id<br/> LEFT JOIN tv_show<br/> ON character_tv_show.tv_show_id = tv_show.id;</code> <br/><br/> Can you use left joins to match character names with the actors that play them?  Select the columns: <strong>character</strong>.<em>name</em>, <strong>actor</strong>.<em>name</em> <br/><br/>Note: Other letiants of SQL have <code>RIGHT JOIN</code> and <code>OUTER JOIN</code>, but those features are not present in SQLite."},

  {"name": "Table alias",
    "short_name": "table_alias",
    "required": ["AS", "c.name", "a.name"],
    "custom_error_message": "You must use table aliases as described above.",
    "database_type": "tv_extra",
    "answer": {"columns": ["name", "name"],
      "values": [["Doogie Howser", "Neil Patrick Harris"],
        ["Barney Stinson", "Neil Patrick Harris"],
        ["Lily Aldrin", "Alyson Hannigan"],
        ["Willow Rosenberg", "Alyson Hannigan"],
        ["Steve Urkel", null],
        ["Homer Simpson", null]]},
    "prompt": "These queries are starting to get pretty long! <br/><br/>In the previous exercise, we ran a query containing the tables <strong>character</strong>, <strong>tv_show</strong>, and <strong>character_tv_show</strong>.  We can write a shorter query if we used aliases for those tables.  Basically, we create a \"nickname\" for that table. <br/><br/> If you want to use an alias for a table, you add <code>AS *alias_name*</code> after the table name. <br/><br/> For example, to use left joins between characters and tv shows with aliases, you would run: <br/> <code>SELECT c.name, t.name<br/>FROM character AS c<br/>LEFT JOIN character_tv_show AS ct<br/>ON c.id = ct.character_id<br/>LEFT JOIN tv_show AS t<br/>ON ct.tv_show_id = t.id;</code> <br/><br/> As you can see, it is shorter than the query in the previous exercise.<br/><br/> Can you use left joins to match character names with the actors that play them, and use aliases to make the query shorter?  The aliases for <strong>character</strong>, <strong>character_actor</strong>, and <strong>actor</strong> should be <strong>c</strong>, <strong>ca</strong>, and <strong>a</strong>. <br/><br/>Select the columns: <strong>c</strong>.<em>name</em>, <strong>a</strong>.<em>name</em>"},

  {"name": "Column alias",
    "short_name": "column_alias",
    "database_type": "tv_extra",
    "answer": {"columns": ["character", "actor"],
      "values": [["Doogie Howser", "Neil Patrick Harris"],
        ["Barney Stinson", "Neil Patrick Harris"],
        ["Lily Aldrin", "Alyson Hannigan"],
        ["Willow Rosenberg", "Alyson Hannigan"],
        ["Steve Urkel", null],
        ["Homer Simpson", null]]},
    "prompt": "In addition to making aliases for tables, you can also make them for columns. <br/><br/>  This clears up confusion on which column is which.  In the previous exercise, both columns in the result are simply called \"name\", and that can be confusing. <br/><br/> If you want to use an alias for a column, you add <code>AS *alias_name*</code> after the column name. <br/><br/>  If we wanted to use left joins between character names and TV shows and clearly denote which column has character names, and which has TV show names, it would look like this: <br/><code>SELECT character.name AS character, tv_show.name AS name<br/> FROM character <br/>LEFT JOIN character_tv_show<br/> ON character.id = character_tv_show.character_id<br/> LEFT JOIN tv_show<br/> ON character_tv_show.tv_show_id = tv_show.id;</code> <br/><br/>Can you use left joins to match character names with the actors that play them, and use aliases to call the two columns returned <em>character</em> and <em>actor</em>?"},

  {"name": "Self joins",
    "short_name": "self_join",
    "database_type": "self_join",
    "answer": {"columns": ["employee_name", "boss_name"],
      "values": [["Patrick Smith", "Abigail Reed"],
        ["Abigail Reed", "Bob Carey"],
        ["Bob Carey", "Maxine Tang"]]},
    "prompt": "Sometimes, it may make sense for you to do a self join.  In that case, you need to use table aliases to determine which data is from the \"first\"/\"left\" table. <br/><br/>For example, to get a list of Rock Paper Scissors objects and the objects they beat, you can run the following: <br/><code>SELECT r1.name AS object, r2.name AS beats <br/>FROM rps AS r1 <br/>INNER JOIN rps AS r2 <br/>ON r1.defeats_id = r2.id;</code><br/><br/> Can you run a query that returns the name of an employee and the name of their boss?  Use column aliases to make the columns <em>employee_name</em> and <em>boss_name</em>."},

  {"name": "LIKE",
    "short_name": "like",
    "database_type": "robot",
    "answer": {"columns": ["id", "name"],
      "values": [[1, "Robot 2000"],
        [2, "Champion Robot 2001"],
        [4, "Turbo Robot 2002"],
        [5, "Super Robot 2003"],
        [6, "Super Turbo Robot 2004"]]},
    "prompt": "In SQL, you can use the <code>LIKE</code> command in order to search through text-based values.  With <code>LIKE</code>, there are two special characters: <code>%</code> and <code>_</code>. <br/><br/> The percent sign (<code>%</code>) represents zero, one, or multiple characters. <br/><br/> The underscore (<code>_</code>) represents one character. <br/><br/> For example, <code>LIKE \"SUPER _\"</code> would match values such as \"SUPER 1\", \"SUPER A\", and \"SUPER Z\". <br/><br/> <code>LIKE \"SUPER%\"</code> would match any value where <code>SUPER</code> is at the beginning, such as \"SUPER CAT\", \"SUPER 123\", or even \"SUPER\" by itself. <br/><br/> <code>SELECT * FROM robots WHERE name LIKE \"%Robot%\";</code> would yield all values that contain \"Robot\" in the name.  Can you run a query that returns \"Robot\" followed by a year between 2000 and 2099? (So 2015 is a valid value at the end, but 2123 is not.) <br/><br/> Note: <code>LIKE</code> queries are <strong>not</strong> case sensitive."},

  {"name": "CASE",
    "short_name": "case",
    "database_type": "amis_chaton",
    "answer": {"columns": ["id", "name", "gender", "type", "taille_cm", "sound"],
      "values": [[1, "Dave", "male", "human", 180, "talk"],
        [2, "Marie", "female", "human", 160, "talk"],
        [3, "Frisou", "male", "cat", 30, "meow"],
        [4, "Leela", "female", "cat", 25, "meow"],
        [5, "Odie", "male", "chien", 40, "bark"],
        [6, "Pitou", "male", "chien", 35, "bark"],
        [7, "Jojo", "male", "chien", 55, "bark"]]},
    "prompt": "You can use a <code>CASE</code> statement to return certain values when certain scenarios are true. <br/><br/> A <code>CASE</code> statement takes the following form: <br/><br/> <code>CASE WHEN *first thing is true* THEN *value1*<br/>WHEN *second thing is true* THEN *value2*<br/>...<br/>ELSE *value for all other situations* <br/> END </code> <br/><br/> For example, in order to return the number of legs for each row in <strong>amis_chaton</strong>, you could run: <br/> <code>SELECT *, <br/> CASE WHEN type = 'human' THEN 2 ELSE 4 END AS num_legs <br/> FROM amis_chaton;</code><br/><br/> Can you return the results with a column named <em>sound</em> that returns \"talk\" for humans, \"bark\" for chiens, and \"meow\" for cats?"},

  {"name": "SUBSTR",
    "short_name": "substr",
    "database_type": "robot_code",
    "answer": {"columns": ["id", "name", "location"],
      "values": [[1, "R2000 - Robot 2000", "New City, NY"],
        [3, "D0001 - Dragon", "New York City, NY"],
        [4, "R2002 - Turbo Robot 2002", "Spring Valley, NY"],
        [5, "R2003 - Super Robot 2003", "Nyack, NY"],
        [8, "U2111 - Unreleased Turbo Robot 2111", "Buffalo, NY"]]},
    "prompt": "In SQL, you can search for the substring of a given value.  Perhaps a location is stored in the format \"city, state\" and you just want to grab the state. <br/><br/> SUBSTR is used in this format: <code>SUBSTR(<em>column_name</em>, <em>index</em>, <em>number_of_characters</em>)</code> <br/><br/> <em>index</em> is a number that denotes where you would start the substring.  1 would indicate the first character, 2 would indicated the second character, etc.  The index could also be negative, which means you would count from the end of the string.  -1 would denote the last character, -2 would denote the 2nd to last character, etc. <br/><br/> <em>number_of_characters</em> is optional; if it is not included, the substring contains the \"rest of the string\". <br/><br/>Here are some examples:<br/> <code>SUBSTR(name, 1, 5)</code> is the first 5 characters of the name. <br/> <code>SUBSTR(name, -4)</code> is the last 4 characters of the name. <br/><br/><code>SELECT * FROM robots WHERE SUBSTR(name, -4) LIKE '20__';</code> is another way of returning all of the robots that have been released between 2000 and 2099.<br/><br/>Note: In other versions of SQL, you could use <code>RIGHT</code> to do this.<br/><br/> Can you return all of the robots that are located in NY?"},

  {"name": "COALESCE",
    "short_name": "coalesce",
    "database_type": "fighting",
    "answer": {"columns": ["name", "weapon"],
      "values": [["US Marine", "M1A1 Abrams Tank"],
        ["John Wilkes Booth", ".44 caliber Derringer"],
        ["Zorro", "Sword of Zorro"],
        ["Innocent Bystander", null]]},
    "prompt": "<code>COALESCE</code> takes a list of columns, and returns the value of the first column that is not null. <br/><br/>Suppose we wanted to find the most powerful weapon that a combatant has on hand.  If value of <em>gun</em> is not null, that is the value returned.  Otherwise, the value of <em>sword</em> is returned.  Then you would run: <br/> <code>SELECT name, COALESCE(gun, sword) as weapon FROM fighters;</code> <br/><br/> Suppose that a fighter's tank could count as a weapon, and it would take precedence over the gun and the sword.  Could you find each fighter's weapon in that scenario?"}
]